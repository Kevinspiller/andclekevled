Possíveis erros:


Primeiro – Vazamento de Memória.

==20058== 6 bytes in 2 blocks are definitely lost in loss record 7 of 51
==20058==    at 0x4C28C50: malloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==20058==    by 0x405D05: getInsertedValue (sqlcommands.c:88)
==20058==    by 0x4073C1: insert (sqlcommands.c:542)
==20058==    by 0x40B3BB: interface (parser.c:234)
==20058==    by 0x408AF2: main (uffsdb.c:30)

  Na função getInsertedValue é alocado um espaço que é atribuído a um ponteiro.
	Linha 88 → sqlcommands.c → noValue = (char *)malloc(sizeof(char)*3);

  Que ao final da função é retornado, o noValue. Então temos a função  insert.
	Linha 542 →  sqlcommands.c → 	colunas = insereValor(tabela, colunas, esquema->nome, getInsertedValue(s_insert, esquema->nome, tabela));

   A função insert  na chamada da função insereValor  envia como último parâmetro o retorno da função getInsertedValue, o noValue.

  A função insereValor está no arquivo dictionary.c, em que o ponteiro *valorCampo aponta para o noValue. Então no decorrer de toda a função não é liberado o espaço alocado lá em getInsertedValue referente ao noValue, nem enviado o endereço do valorCampo para outra função.

Solução: free(valorCampo); → antes do return no final da função.



Segundo – Vazamento de Memória

==20058== 7 bytes in 1 blocks are definitely lost in loss record 9 of 51
==20058==    at 0x4C28C50: malloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==20058==    by 0x40260B: dbInit (database.c:215)
==20058==    by 0x408ADE: main (uffsdb.c:28)

 Na função dbInit em database.c é alocado espaço para um ponteiro chamado name, que é enviado como parâmetro na chamada a função createDB, a função createDB também está no arquivo database.c, e db_name recebe name. E na função inteira em nenhum momento é liberado o espaço alocado em db_name.

Solução: free(db_name); → no final da função createDB.
